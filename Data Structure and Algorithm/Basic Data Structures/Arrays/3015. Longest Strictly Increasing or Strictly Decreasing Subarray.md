#DSA #Arrays #Easy #Counting
___
# Problem
==Link:== [Leetcode Problem Link](https://leetcode.com/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/description/?envType=daily-question&envId=2025-02-03)
You are given an array of integers `nums`. Return the length of the longest 
subarray of `nums` which is either strictly increasing or strictly decreasing.

**Example 1:**
	**Input:** nums = [1,4,3,3,2]
	**Output:** 2
	**Explanation:**
		The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].
		The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].
		Hence, we return 2.

**Example 2:**
	**Input:** nums = [3,3,3,3]
	**Output:** 1
	**Explanation:**
		The strictly increasing subarrays of nums are [3], [3], [3], and [3].
		The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
		Hence, we return 1.

**Example 3:**
	**Input:** nums = [3,2,1]
	**Output:** 3
	**Explanation:**
		The strictly increasing subarrays of nums are [3], [2], and [1].
		The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].
		Hence, we return 3.

**Constraints:**
- 1 â‡ `nums.length` â‡ 50
- 1 â‡ `nums[i]` â‡ 50
___
# First Solution
**==Solution Link==**: [Solution](https://leetcode.com/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/solutions/6365080/two-counter-1-pass-explained-with-example-100-beats)
> Approach:
>- ğŸ¯ Track Two Counters: Maintain separate counters for increasing and decreasing streaks.
> -ğŸ”„ Update Counters: For each element, compare with the previous:
	Increase Streak â†—ï¸ if current > previous.
	Decrease Streak â†˜ï¸ if current < previous.
	Reset Both â¹ï¸ if equal.
>- ğŸ“ˆ Track Maximum: After each step, update the global maximum length.
```java
class Solution {
    public int longestMonotonicSubarray(int[] nums) {
        int increase = 1, decrease = 1, streak = 1;
        for (int i = 0; i < nums.length - 1; ++i) {
            if (nums[i] < nums[i + 1]) {
                ++increase;
                decrease = 1;
            }
            else if (nums[i] > nums[i + 1]) {
                ++decrease;
                increase = 1;
            }
            else {
                increase = 1;
                decrease = 1;
            }
            streak = Math.max(streak, Math.max(increase, decrease));
        }
        return streak;
    }
}
```
Time-Complexity: $O(n)$
Space-Complexity: $O(1)$