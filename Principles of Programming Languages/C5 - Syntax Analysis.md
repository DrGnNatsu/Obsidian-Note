#ppl 
___
# Recall
___
**The output of input through the Lexical Analyzer**(Lexer, Scanner): Translate the lexeme into a sequence of tokens.
# Introduction
---
Roles of syntax analysis: 
- Read the sequence of tokens.
- Produce as output a parse tree or abstract syntax tree (Parse tree).
- Give an error message when detecting syntax errors.
![[Interactions between the lexical analyzer and the parser.png]]

**Symbol Table:** Define the keywords that the machine can accept.

![[Position of parser in compiler model.png]]
# The Functionality of the Parser
___
![[Position of parser in compiler model.png]]
**Input:** sequences of lexemes
**Output:** parse tree (AST)
# Possible Parse Tree
If-then-else statement:
```
if(x==y) then z=1; else z=2;
```
Parse Input
```
IF (IDENT == IDENT) THEN IDENT=NUM ; ELSE IDENT=NUM;
```
![[Possible Parse Tree.png]]
# The Role of Parser
---
Not all sequences of tokens are programs (if they follow the rules, it is valid, called by a program). Parsers must *distinguish between valid and invalid* sequences of tokens.   
We need: 
- *A language for describing valid* sequences of tokens
- *A method for distinguishing valid from invalid* sequences of tokens.
# Syntactic Analysis
---
Lexical Analysis was about ensuring that we extract a set of valid words (i.e., tokens/lexemes) from the source code. But nothing says that the words make a coherent sentence (i.e., program).
# Context Free Grammar (CFG)
---
A context-free grammar is a **set of recursive rules used to generate patterns of strings**. CFGs are studied in fields of theoretical computer science, compiler design, and linguistics.
- Context-free: Does not depend on the context (in every *scenario*, it has only one meaning)
- Ref: CSG: content-sensitive Grammar.
## CFG
---
Grammar: $G=(V,\Sigma,S,P)$, with:
- $V$ is variables (syntactic variables, non-terminal). These symbols *can be replaced* by other symbols according to the production rules. " Each nonterminal represents a set of strings of terminals
- $\Sigma$ These are **terminal symbols**. These symbols appear in the strings generated by the grammar and *cannot be replaced*. The terminals are the elementary symbols of the language dened by the grammar. It is indivisible.
- $S$ is a start variable. Only a special *non-terminal symbol* from which the **derivation process begins**.
	- Derivation process: is the process which do replacement. 
	- $S \in V$: one character in V will be used to be start variable.
- $P$ is production rules. Rules that specify how non-terminal symbols can be replaced by combinations of terminal and/or non-terminal symbols.
## What is Production
---
Production Rule of the form: $A \rightarrow a$, where $a=\{V \cup \Sigma\}^*$ and $A \in V$
> LHS can replace with RHS , where $\text{RHS} = V \cup \Sigma$ and $A \in V$.
## The Language of a CFG
---
Read productions as replacement rules.
- $X \rightarrow {Y_1 \cdots Y_n}$: Means $X$ can be replaced by $Y_1 \cdots Y_n$
- $X \rightarrow \varepsilon$ : Means $X$ can be erased (replaced with the empty string)
## Key Idea
---
1. Begin with a string consisting of the start symbol "$S$"
2. Replace any non-terminal $X$ in the string by the right-hand side of some production.
$$X \rightarrow {Y_1 \cdots Y_n}$$
3. Repeat step 2 until there are no non-terminals in the string.
## Purpose of the Production Rule
---
- Defining Language Syntax
- Generating Strings
- Parsers use rules to check grammatical structure
- Precedence and Associativity
## CFG - Example
---
Grammar for simple arithmetic expressions:
$$
\begin{align*}
	expression &\rightarrow expression + term \\
	expression &\rightarrow expression - term \\
	expression &\rightarrow term \\
	term &\rightarrow term * factor \\  
	term &\rightarrow term / factor \\
	term &\rightarrow factor  \\
	factor &\rightarrow ( expression ) \\  
	factor &\rightarrow id \\
\end{align*}
$$

# Notational Conventions (- ref.)
---
1. **These symbols are terminals:**
   - (a) Lowercase letters early in the alphabet, such as *a*, *b*, *c*.  
   - (b) Operator symbols such as `+`, `*`, and so on.  
   - (c) Punctuation symbols such as parentheses, comma, and so on.  
   - (d) The digits `0, 1, …, 9`.  
   - (e) Boldface strings such as **id** or **if**, each of which represents a single terminal symbol.
1. **These symbols are nonterminals:**
   - (a) Uppercase letters early in the alphabet, such as *A*, *B*, *C*.  
   - (b) The letter *S*, which, when it appears, is usually the start symbol.  
   - (c) Lowercase, italic names such as *expr* or *stmt*.  
   - (d) When discussing programming constructs, uppercase letters may be used to represent nonterminals for the constructs.  
     For example, nonterminals for expressions, terms, and factors are often represented by **E**, **T**, and **F**, respectively.
# Notational Conventions
---
$expression \rightarrow expression + term$  
$expression \rightarrow expression - term$  
$expression \rightarrow term$  
$term \rightarrow term * factor$  
$term \rightarrow term / factor$  
$term \rightarrow factor$  
$factor \rightarrow ( expression )$  
$factor \rightarrow id$
Equivalent compact form:
$E \rightarrow E + T \;|\; E - T \;|\; T$  
$T \rightarrow T * F \;|\; T / F \;|\; F$  
$F \rightarrow ( E ) \;|\; id$
# Derivation
---
- **Steps**: 
1.  Identify a non-terminal symbol in the current string; 
2. Replace this non-terminal symbol with the right-hand side of one of its production rules. 
- **Types**: 
1. Leftmost: pick the element in the rightmost to use production rule.
2. Rightmost: pick the element in the leftmost to use production rule.