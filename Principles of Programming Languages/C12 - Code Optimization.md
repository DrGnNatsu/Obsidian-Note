---
tags:
  - ppl
---
# Where can we optimise so far ...?
The **Code Optimiser** is a phase in the compiler pipeline that operates on the **intermediate code** generated by the Front End (which includes lexical, parsing, and semantic analysis) and produces a more efficient version of the intermediate code to be fed into the Code Generator. But the goal of the code does not change
> [!info] Definition of IR?
> IR: Intermediate Representations: The intermediate state that the compiler uses to analyse and optimise the AST, ...

> Why do we only imply code optimisation after IC generation?
> If you do not use it, you will create redundant steps to compute the value â†’ Increase the compile time.
# Code Optimisation: Requirements & Opportunities
## Requirements
- **Meaning must be preserved (correctness)**: The optimised code must produce the same output and have the same side effects as the original code.
- **Speedup must occur on average**: the optimisation should result in performance improvements for typical use cases.
- **Work done must be worth the effort**: The time and resources spent on optimisation should justify the performance gain.
## Opportunities
Optimisation can occur at different levels:
- **Programmer**: Algorithm choice, compiler directives.
- **Intermediate code** (IC = ): The focus of this lecture.
- **Target code**: Machine-specific optimisations.
# Levels of Code Optimisation
- **Window - peephole optimisation**: Looks at a small, fixed-size window of instructions.
- **Basic block**: Optimises a sequence of straight-line code.
- **Procedural - global (control flow graph)**: Optimises across an entire procedure or function.
- **Program level - intraprocedural (program dependence graph)**: Optimises across the entire program.
# Peephole Optimizations
- **Goal**: Make local improvements to the code to improve performance or reduce code size.
- **Advantages**:
    - **Speed**: Can be applied quickly without extensive analysis.
    - **Simplicity**: Involves direct replacements or eliminations of instructions.
    - **Effectiveness**: Significant performance improvements by eliminating obvious inefficiencies.
## Peephole Optimisation Techniques
1.  **Constant Folding**: Evaluate constant expressions at compile time. Try to evaluate at compile time, not at runtime. 
    - `x = 5 + 3;` becomes `x = 8;`.
    - `result = (True and False) or (not False)` becomes `result = True`.
2.  **Unreachable Code Elimination**: Remove code that can never be executed.
    - A statement after an unconditional `goto` is unreachable.
    - A statement after a `return` is unreachable.
3.  **Flow of Control Optimisations**: Simplify jumps and conditional statements.
    - `goto L1; ... L1: goto L2;` becomes `goto L2;`.
    - `if True: do_something() else: ...` becomes `do_something()`.
4.  **Algebraic Simplification**: Replace expensive operations with cheaper ones using algebraic identities.
    - `x := x + 0` can be deleted.
    - `y := y ** 2` can be simplified to `y := y * y`.
    - `x := x * 8` can be simplified to `x := x << 3` (on some machines).
5.  **Dead Code Elimination**: Remove a statement if its result is never used later.
    - `x := 32; y := x + y;` (where `x` is not used again) becomes `y := y + 32;`.
# Basic Block Level Optimisations
Optimisations applied within a **basic block**.
- **Common subexpression elimination**.
- **Constant propagation**.
- **Dead code elimination**.
- Plus others like copy propagation, value numbering, etc.
## Definition: Basic Blocks
A **basic block** is a maximal sequence of instructions with:
- No labels (except at the first instruction).
- No jumps (except in the last instruction).

> [!note] Inside the basic blocks, label is just a label. Do not put it in the basic black representations.

# Control Flow Graph (CFG)
- A representation of the flow of control within a program.
- **CFG = < V, E, Entry >**, where:
    - **V**: Vertices or nodes, representing an instruction or basic block.
    - **E**: Edges, representing potential flow of control.
    - **Entry**: The unique program entry block.
- **Point**: Any location between adjacent statements or before/after a basic block.
- **Path**: A sequence of points from a start point to an end point in the CFG.

Example:
- Succ(4) = 4,5
- Pred(4) = 3
# Optimisations on CFGs
These optimisations must take control flow into account:
- Common Sub-expression Elimination
- Constant Propagation
- Dead Code Elimination
- Partial Redundancy Elimination
- ...
Applying one optimisation may create opportunities for others.
## Redundant Expression
- An expression `x op y` is **redundant** at a point `p` if it has already been computed and its operands (`x`, `y`) have not been redefined.
- **Definition site**: Where an expression is computed.
- **Kill site**: Where an operand of an expression is redefined.
- An expression is **available** at point `p` if every path leading to `p` contains a prior definition of the expression, and the expression is not killed between that definition and `p`.
(See CFG examples on pages 29 and 30 illustrating available and non-available expressions).